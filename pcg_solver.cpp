#include <iostream>
#include <vector>
#include <fstream>
#include <cmath>
#include <string>
#include <chrono>
#include <iomanip>
#include <cassert>
#include <type_traits>

// ---------------- Compressed Sparse Row (CSR) Matrix ----------------
/**
 * CSR Matrix Structure 
 * Represents the 5-point finite-difference Laplacian
 */
struct CSRMatrix
{
    int n; // Number of rows/cols
    std::vector<int> rowptr;
    std::vector<int> col;
    std::vector<double> val;
};

// ---------------- Utilities ----------------
// Helper to load CSV files generated by the Poisson script

// Generic converter string to type T
template <typename T>
T convert(const std::string& s);

// Explicit conversion specialization for int and double types
template <>
int convert<int>(const std::string& s)
{
    return std::stoi(s);
}

template <>
double convert<double>(const std::string& s)
{
    return std::stod(s);
}

// Template CSV reader function
template <typename T>
std::vector<T> read_csv(const std::string& filename)
{
    static_assert(std::is_arithmetic<T>::value,
                  "read_csv only supports arithmetic types");
    std::ifstream file(filename);
    std::vector<T> data;
    std::string line;

    while (std::getline(file, line))
    {
        if (!line.empty())
            data.push_back(convert<T>(line));
    }

    return data;
}

/**
 * Prints the matrix in a dense format for debugging.
 * Only recommended for very small N (e.g., N < 10).
 */
void print_sparse_matrix(const CSRMatrix& A)
{
    std::cout << "Reconstructed Matrix (N=" << A.n << "):" << std::endl;

    for (int i = 0; i < A.n; ++i)
    {
        int current_col_idx = 0;
        std::cout << "Row " << i << ": ";

        // CSR rows are defined by the range [rowptr[i], rowptr[i+1])
        for (int j = A.rowptr[i]; j < A.rowptr[i + 1]; ++j)
        {
            int col_val = A.col[j];
            double value = A.val[j];

            // Print zeros for gaps between non-zero elements
            while (current_col_idx < col_val)
            {
                std::cout << std::setw(3) << "0 ";
                current_col_idx++;
            }

            std::cout << std::setw(3) << value << " ";
            current_col_idx++;
        }

        // Print remaining zeros in the row
        while (current_col_idx < A.n)
        {
            std::cout << std::setw(3) << "0 ";
            current_col_idx++;
        }
        std::cout << std::endl;
    }
}

// ---------------- Linear Algebra Ops ----------------
// Sparse Matrix-Vector Multiply (SpMV): y = A * x
void spmv(const CSRMatrix& A,
          const std::vector<double>& x,
          std::vector<double>& y)
{
    std::fill(y.begin(), y.end(), 0.0);
    for (int i = 0; i < A.n; ++i)
    {
        for (int jj = A.rowptr[i]; jj < A.rowptr[i + 1]; ++jj)
        {
            y[i] += A.val[jj] * x[A.col[jj]];
        }
    }
}

// Dot Product: x^T * y
double dot(const std::vector<double>& a,
           const std::vector<double>& b)
{
    double sum = 0.0;
    for (size_t i = 0; i < a.size(); ++i)
        sum += a[i] * b[i];
    return sum;
}

// Vector Update (AXPY): y = a * x + y
void axpy(double alpha,
          const std::vector<double>& x,
          std::vector<double>& y)
{
    for (size_t i = 0; i < y.size(); ++i)
        y[i] += alpha * x[i];
}

// ---------------- PCG Solver ----------------
// Implement PCG with Jacobi Preconditioning
int pcg(const CSRMatrix& A,
        const std::vector<double>& b,
        std::vector<double>& x,
        const double tol,
        const int maxIt,
        double& solve_time,
        std::vector<double>& residuals)
{
    const int n = A.n;

    std::vector<double> r(n, 0.), z(n, 0.), p(n, 0.), Ap(n, 0.);
    std::vector<double> Minv(n, 0.);

    // Jacobi preconditioner: M^-1 = 1/diag(A) 
    // For 2D Poisson, diag(A) is 4
    for (int i = 0; i < n; ++i)
    {
        bool found_diagonal_entry = false;
        for (int jj = A.rowptr[i]; jj < A.rowptr[i + 1]; ++jj)
        {
            if (A.col[jj] == i)
            {
                assert(A.val[jj] > 0.0 && "Negative diagonal entry in CSR row"); // SPD assumption
                Minv[i] = 1.0 / A.val[jj];
                found_diagonal_entry = true;
                break;
            }
        }
        assert(found_diagonal_entry && "Missing diagonal entry in CSR row");
    }

    // Initial residual: r = b - A*x (x is initially zeros)
    // r = b - A x
    spmv(A, x, Ap);
    for (int i = 0; i < n; ++i)
        r[i] = b[i] - Ap[i];

    const double bnorm = std::sqrt(dot(b, b));

    // Preconditioning: z = M^-1 * r
    // z = M^{-1} r
    for (int i = 0; i < n; ++i)
        z[i] = Minv[i] * r[i];

    p = z;
    double rz_old = dot(r, z);
    
    std::cout << "Starting PCG Solver." << std::endl;
    std::cout << "Iter | Relative Residual" << std::endl;
    std::cout << "------------------------" << std::endl;
    
    // Start timer for PCG iteration loop (solver-only)
    // excluding matrix loading and setup
    auto t_start = std::chrono::steady_clock::now();

    for (int k = 0; k < maxIt; ++k)
    {
        spmv(A, p, Ap);

        // check for divison by ~ 0
        if (std::abs(dot(p, Ap)) < 1e-30)
            break;

        const double alpha = rz_old / dot(p, Ap);

        axpy(alpha, p, x);  // x = x + alpha*p
        axpy(-alpha, Ap, r);  // r = r - alpha*Ap

        const double rnorm = std::sqrt(dot(r, r));
        std::cout << "Iter " << k
                  << " |r|/|b| = " << rnorm / bnorm << std::endl;
        residuals.push_back(rnorm / bnorm);

        // Converged state
        if (rnorm / bnorm < tol)
        {
            auto t_end = std::chrono::steady_clock::now();
            solve_time = std::chrono::duration<double>(t_end - t_start).count();
            return k + 1; 
        }

        // Apply Preconditioner
        for (int i = 0; i < n; ++i)
            z[i] = Minv[i] * r[i];

        const double rz_new = dot(r, z);

        // check for divison by ~ 0
        if (std::abs(rz_old) < 1e-30)
            break;

        const double beta = rz_new / rz_old;

        // p = z + beta*p
        for (int i = 0; i < n; ++i)
            p[i] = z[i] + beta * p[i];

        rz_old = rz_new;
    }

    auto t_end = std::chrono::steady_clock::now();
    solve_time = std::chrono::duration<double>(t_end - t_start).count();
    return maxIt;
}

// ---------------- Main ----------------
int main(int argc, char* argv[])
{
    if (argc < 2)
    {
        std::cerr << "Usage: ./pcg <matrix_dir>\n";
        return 1;
    }

    std::string dir = argv[1];

    CSRMatrix A;
    A.rowptr = read_csv<int>(dir + "/rowptr.csv");
    A.col    = read_csv<int>(dir + "/col.csv");
    A.val    = read_csv<double>(dir + "/val.csv");
    A.n      = A.rowptr.size() - 1;

    // Debug CSR by printing for small case like 3x3 matrix A
    //print_sparse_matrix(A);

    // After loading CSR
    assert(A.rowptr.front() == 0);
    assert(A.rowptr.back() == static_cast<int>(A.col.size()));
    assert(A.col.size() == A.val.size());

    const std::vector<double> b(A.n, 1.0); // b is all-ones
    std::vector<double> x(A.n, 0.0); // x0 is all-zeros
    
    double solve_time = 0.0;
    const double tol = 1e-8;
    const int maxIt = 10000;
    std::vector<double> residuals;

    int iters = pcg(A, b, x, tol, maxIt, solve_time, residuals);
    
    std::ofstream resfile("residuals.csv");
    for (size_t i = 0; i < residuals.size(); ++i)
        resfile << i << "," << residuals[i] << "\n";

    std::cout << "------------------------" << std::endl;
    std::cout << "Converged in " << iters << " iterations\n";
    std::cout << "Solve time: " << solve_time << " seconds\n";
    return 0;
}

